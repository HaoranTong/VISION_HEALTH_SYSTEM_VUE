下面是一个详细的示例说明，描述系统从用户操作到最终报表展示的全部流程，不省略任何中间过程。

------

## 示例场景

用户在自定义查询模式下进行如下操作：

1. **筛选条件设置**
   - **学校**：
      用户在筛选区域中选择字段“学校”，并在该条件下从下拉列表中选择了具体选项“兴华小学”。
   - **性别**：
      用户又添加了一条筛选条件，选择字段“性别”，并在对应复选框中勾选了“男”。
2. **统计指标选择**
   - 用户添加一条条件，选择字段“视力等级”作为统计指标。在该条件中，用户明确勾选了该字段下所有的子选项（例如：“临床前期近视”、“轻度近视”、“中度近视”）。
3. **分组条件设置**
   - 用户添加一条条件，选择字段“年龄”作为分组指标。
   - 用户希望对“年龄”进行分段统计，因此他设置了两个区间：
     - 一个区间表示 6-9 岁
     - 另一个区间表示 10-12 岁
   - 注意：在本系统中，分组条件只取用户选择的第一个分组字段（这里为“年龄”），区间信息可能通过后续逻辑将这两个区间一起作为 distinct 值传递给后端进行统计。
4. **固定筛选项**
   - 此外，用户在固定区域（例如一个专门的年份选择控件）选择了数据年份“2023”。

------

## 前端数据收集与参数传递

1. **固定查询参数收集**

   - 系统在页面的固定筛选区域中，直接读取如数据年份（`statTime=2023`）、学校（如果有在固定区域输入的话，但在自定义模式下主要依赖组合查询条件）。
   - 这些参数会通过 `getReportQueryParams()` 函数使用 DOM 元素的值来创建 URLSearchParams 对象，并附加到 GET 请求中。

2. **组合查询条件收集**

   - 用户在自定义查询区域中添加了多条查询条件，每一行由组合查询模块生成（专用的 comboQuery_report.js）。

   - 每条条件行会包含：

     - **角色（role）**：
        对于筛选条件，角色为 "filter"；
        对于统计指标，角色为 "metric"；
        对于分组条件，角色为 "group"。

     - **字段（field）**：例如 "school"、"gender"、"vision_level"（视力等级）、"age"。

     - **运算符（operator）**：例如对于筛选条件常用 "like"；对于区间查询可能为 "between" 或 ">"、"<"。

     - 值（value）

       ：

       - 对于“学校”，值直接是字符串 "兴华小学"；
       - 对于“性别”，值为数组 ["男"]（因为复选框多选模式）；
       - 对于统计指标“视力等级”，值为数组 ["临床前期近视", "轻度近视", "中度近视"]（用户全选）；
       - 对于分组条件“年龄”，由于分组条件只需选择字段本身，此处不需要具体的值（或值为空），但实际为了实现分段统计，前端可能会额外以区间的方式传递，比如把 6-9 岁和 10-12 岁以区间对象传递。不过根据需求，分组条件只取第一个分组字段，所以只取第一条作为主分组依据，另一部分区间可以作为统计指标的 distinct 值传递给后端，或者需要由用户单独构造。

   - 这些条件最终会由 getComboConditions() 函数遍历所有条件行，生成一个条件数组，例如：

     ```json
     [
       {"role": "filter", "field": "school", "operator": "like", "value": "兴华小学"},
       {"role": "filter", "field": "gender", "operator": "like", "value": ["男"]},
       {"role": "metric", "field": "vision_level", "operator": "like", "value": ["临床前期近视", "轻度近视", "中度近视"]},
       {"role": "group", "field": "age", "operator": "between", "value": {"min":6,"max":9}},
       {"role": "group", "field": "age", "operator": "between", "value": {"min":10,"max":12}}
     ]
     ```

   - 前端会把这个数组用 JSON.stringify() 转换为字符串，然后附加到 URL 参数 advanced_conditions 中。

3. **最终请求参数**

   - GET 请求的 URL 可能类似：

     ```
     /api/analysis/report?stat_time=2023&advanced_conditions=[{"role":"filter","field":"school","operator":"like","value":"兴华小学"},{"role":"filter","field":"gender","operator":"like","value":["男"]},{"role":"metric","field":"vision_level","operator":"like","value":["临床前期近视","轻度近视","中度近视"]},{"role":"group","field":"age","operator":"between","value":{"min":6,"max":9}},{"role":"group","field":"age","operator":"between","value":{"min":10,"max":12}}]
     ```

   - 同时，如果用户输入了报表名称，则附加参数 report_name（例如 "自定义统计报表"）。

------

## 后端处理与统计计算

1. **参数解析**

   - 后端在 analysis_api.py 中首先解析 GET 请求参数。
   - 固定筛选条件（如 stat_time）用于过滤数据，如仅统计 2023 年的数据；学校条件和性别条件分别作为过滤条件加入查询。
   - 自定义查询模式下，会解析 advanced_conditions 字符串生成条件列表。
     - 对于 role 为 "filter" 的条件，生成相应的 SQLAlchemy 过滤条件（例如：学校 LIKE "%兴华小学%"、性别 in ("男")）。
     - 对于 role 为 "metric" 的条件，后端检查：如果该条件的 value 为空，则报错提示用户必须选择至少一个子选项；否则，将该条件存储到 metric_conditions 列表中。
     - 对于 role 为 "group" 的条件，后端只依赖字段名称来构造分组表达式。如果 advanced_conditions 中有多条分组条件，则只取第一条作为主分组依据（其余忽略）。

2. **构造分组表达式**

   - 固定模板模式下：
     - template1（按年龄段）：使用 case() 表达式将 age 分为 “6-9岁”、“10-12岁”及“其他”；
     - template2（按性别）：直接使用 Student.gender 作为分组字段。
   - 自定义查询模式下：
     - 使用 advanced_conditions 中第一条 role 为 "group" 的条件对应字段构造分组表达式。
     - 同时，对于分组字段的显示，会使用 FIELD_DISPLAY_MAPPING 将其转换为中文名称（例如将 "gender" 映射为“性别”）。

3. **统计指标聚合**

   - 对于每个统计指标条件（role 为 "metric"），后端根据用户选择的子选项生成 dynamic_metrics 数组。

     - 例如，统计指标“视力等级”的条件会产生一个对象：

       ```python
       {"field": "vision_level", "label": "视力等级", "distinct_vals": ["临床前期近视", "轻度近视", "中度近视"]}
       ```

     - 然后，对于每个子选项（例如“轻度近视”），构造 SQLAlchemy 聚合表达式：

       ```python
       func.sum(case((get_column_by_field("vision_level") == "轻度近视", 1), else_=0)).label("vision_level_轻度近视_count")
       ```

   - 最后，构造的查询列为：

     - 第一列：分组表达式（显示分组值）；
     - 中间列：每个统计指标子选项的计数列（交替后期计算占比）；
     - 最后一列：总记录数（func.count()）。

4. **数据行与合计行构造**

   - 后端执行查询后，生成的数据行格式为二维数组：
     - 第一列为分组值；
     - 中间部分交替为每个统计指标子选项的“数量”和“占比”；
     - 最后一列为统计总数。
   - 合计行会汇总所有数据行的数值，并计算各列的占比（按总数计算百分比）。

5. **表头构造**

   - 表头由 build_multi_level_header() 函数生成，采用三行结构：
     - 第一行：
       - 第一列为分组字段名称（经过映射显示，例如“年龄”）；
       - 接下来为统计指标字段名称（如“视力等级”），此单元格横跨该指标下所有子选项列；
       - 最后一列为“统计总数”。
     - 第二行：
       - 第一列为空；
       - 中间部分显示每个统计指标下用户选择的具体子选项（例如“临床前期近视”、“轻度近视”、“中度近视”）；
       - 最后一列为空。
     - 第三行：
       - 第一列为空；
       - 中间部分重复显示每个子选项下固定的“数量”和“占比”两个单元格；
       - 最后一列为空。

6. **报表名称与附注**

   - 如果是固定模板模式，则报表名称固定为“{stat_time}-学生视力统计表”。
   - 如果是自定义模式，则使用用户输入的报表名称，否则默认为“统计报表”。
   - 附注中显示所有固定筛选条件，比如“统计时间：2023”、“学校：兴华小学”、“性别：男”，使用户确认当前生效的筛选条件。

------

## 最终展示结果

假设统计结果如下（以简化数据举例）：

- 数据分组（基于“年龄”字段）：假设 6-9 岁组和 10-12 岁组
- 统计指标为“视力等级”，用户选择了三个子选项：
  - 对于 6-9 岁组，统计数据为：
    - 临床前期近视：数量 10，占比 25%
    - 轻度近视：数量 20，占比 50%
    - 中度近视：数量 10，占比 25%
    - 总记录数：40
  - 对于 10-12 岁组，统计数据为：
    - 临床前期近视：数量 15，占比 30%
    - 轻度近视：数量 25，占比 50%
    - 中度近视：数量 10，占比 20%
    - 总记录数：50

生成的报表可能显示为：

**表头：**

- 第一行：

  | 年龄 | 视力等级（跨 6 列） | 统计总数 |
  | ---- | ------------------- | -------- |
  |      |                     |          |

- 第二行：
   |      | 临床前期近视 | 轻度近视 | 中度近视 |      |      |      | |      | (跨2列)    | (跨2列)    | (跨2列)    |      |      |      |

- 第三行：
   |      | 数量 | 占比 | 数量 | 占比 | 数量 | 占比 |      |

**数据行：**

- 第一行（6-9 岁组）：
   | 6-9岁 | 10 | 25% | 20 | 50% | 10 | 25% | 40 |
- 第二行（10-12 岁组）：
   | 10-12岁 | 15 | 30% | 25 | 50% | 10 | 20% | 50 |
- 合计行：
   | 合计 | 25 | 25% | 45 | 50% | 20 | 25% | 90 |

**报表名称与附注：**

- 报表名称显示为“2023-学生视力统计表”（如果使用固定模板）或自定义输入的名称。
- 附注显示为“统计时间：2023  学校：兴华小学  性别：男”。

------

以上就是整个系统从前端参数收集到后端统计计算，再到报表生成和最终展示的详细过程。

请确认以上描述是否清楚、完整，或是否需要进一步补充说明。

下面是我的理解，请确认是否符合要求：

1. **分组字段名称**
   - 用户在自定义查询中选择的分组字段，比如“年龄”、“性别”、“学校”等，会直接成为报表第一列的列名。例如，如果用户选择“性别”作为分组字段，则表格第一列的标题为“性别”。
2. **分组字段的二级选项**
   - 对于分组字段，其下的每个具体取值或区间（即二级选项）决定了统计分组的维度。
   - 例如：
     - 当分组字段为“性别”时，可能有“男”和“女”两个选项，报表中就会分别生成“男”这一行和“女”这一行；
     - 当分组字段为“年龄”时，如果用户设置了多个区间（例如“6-9岁”与“10-12岁”），那么报表中就会有“6-9岁”一行和“10-12岁”一行。
   - 如果分组字段本身没有二级选项（即没有进一步细分），那么报表中每个分组的数据行就直接对应该字段的单一值。
3. **多个分组字段的情况**
   - 如果用户选择了多个分组字段（例如“拔罐”、“熏蒸”、“热敷”这类单选的字段），系统会将每个字段的名称作为一行的分组标识；
   - 此时，由于报表第一列只显示一个分组字段名称，所以多个分组字段的情况下，建议只取第一个作为分组依据，而其它字段的统计结果会分别以不同报表显示，或由用户明确选择。
4. **报表表头合并规则**
   - 表头设计采用三层结构，但第一列和最后一列不参与分层：
     - 第一列用于显示分组字段的名称，且该列的表头单元格跨三行合并。
     - 最后一列用于显示“统计总数”，也跨三行合并。
   - 中间部分用于显示统计指标的多层表头：
     - 第一行显示统计指标字段的名称（如“视力等级”），这个单元格横跨下方所有子选项的列。
     - 第二行显示用户选择的统计指标的具体子选项（比如“临床前期近视”、“轻度近视”、“中度近视”），对于没有二级选项的统计指标，则直接显示“数量”和“占比”。
     - 第三行固定为“数量”与“占比”两个单元格，分别对应第二行中每个子选项。
5. **总结说明**
   - 分组字段仅指用户选择的用于分组的那一个字段（如“性别”或“年龄”），而其具体取值（例如“男”、“女”或各个年龄段）决定了报表数据行。
   - 第一列的表头（分组字段名称）和最后一列的“统计总数”在整个表头中都要跨三行合并，不参与动态生成多层表头的过程。

请问以上理解是否完全符合您的需求？



下面是实现统计报表模块需求的具体技术方案描述，分为前端和后端两个方面，重点讲解参数采集、数据过滤、分组与统计指标聚合、表头生成、报表名称与附注构造等细节。

------

### 一、前端实现方案

1. **查询条件收集**

   - **固定筛选条件**
      页面上设置专用控件（如下拉框、文本框），例如数据年份选择控件（statTime），这些控件的值直接通过 DOM 读取后，加入 URL 参数中。

   - **组合查询条件**
      使用组合查询模块（独立的 comboQuery_report.js 模块），用户可动态添加查询条件行，每一行包含以下元素：

     - **角色选择下拉框**（role）：用户可选择“统计指标”、“分组”或“筛选”。

     - **字段下拉框**：用户选择具体的数据字段，例如“视力等级”、“性别”、“年龄”等。

     - **运算符选择**：默认一般采用 “like”（对于文本型筛选），区间查询时采用 “between”或分别设置最小值、最大值。

     - 值输入区域

       ：

       - 对于文本和数字类型生成对应的输入框；
       - 对于下拉或多选，生成复选框组；
       - 特别要求：
         - 当作为统计指标的字段在配置中有子选项（例如“视力等级”对应 “临床前期近视”、“轻度近视”、“中度近视”）时，用户必须至少明确勾选一个子选项；否则前端提示错误，不允许提交。

     - 所有条件由 getComboConditions() 函数遍历 DOM 中所有条件行，将每一行的信息构造为一个对象（包含 role、field、operator 和 value），最后将条件数组通过 JSON.stringify() 转换为字符串，并附加到 GET 请求的 advanced_conditions 参数中。

2. **报表名称与附注信息**

   - 报表名称由两种模式确定：
     - **固定模板模式**：用户选择模板后，报表名称固定为“{统计时间}-学生视力统计表”，统计时间从固定控件中获取。
     - **自定义查询模式**：用户可以在输入框中输入报表名称，若未输入则默认使用“统计报表”。
   - 附注信息要求将所有筛选条件（包括固定筛选条件和组合查询中 role 为 “filter” 的条件）以附注形式展示在报表页面右上角，内容格式例如：“统计时间：2023  学校：兴华小学  性别：男”。

3. **表头构造与数据展示**

   - **表头设计采用三层结构**：

     - 第一行

       ：

       - 第一列显示分组字段名称（例如“性别”或“年龄”，经过 FIELD_DISPLAY_MAPPING 映射为中文显示）；该单元格设置行合并，跨 3 行。
       - 中间部分显示统计指标字段名称（例如“视力等级”），该单元格横跨该统计指标下所有子选项的列数（例如每个子选项后面还有两个子列“数量”和“占比”）。
       - 最后一列固定为“统计总数”，同样设置行合并，跨 3 行。

     - 第二行

       ：

       - 第一列为空；
       - 中间部分显示每个统计指标下用户勾选的具体子选项名称，如果该统计指标有子选项，则只显示用户明确选择的那些；如果没有子选项，则直接显示“数量”和“占比”。
       - 最后一列为空。

     - 第三行

       ：

       - 第一列为空；
       - 中间部分对每个子选项固定生成两列，“数量”与“占比”；
       - 最后一列为空。

   - **数据行构造**：

     - 每一行数据的第一列为分组值（例如“男”或“6-9岁”）；
     - 中间部分交替显示每个统计指标子选项的统计数据：先显示计数，再显示占比（占比按该分组内总记录数计算）；
     - 最后一列显示该分组下的统计总数。

4. **前端调用流程**

   - 用户点击“查询”按钮后，前端 report.js 中的 getReportQueryParams() 函数收集所有固定条件和组合查询条件，并构造完整的 GET 请求 URL。
   - 前端发送请求到后端 /api/analysis/report 接口，等待返回统计数据 JSON，然后调用 renderReportHeader() 和 renderReportTable() 函数生成表头和数据行，最后调用 renderReportPagination() 构造分页控件。

------

### 二、后端实现方案

1. **参数解析与过滤**

   - **固定筛选条件**：
      后端首先从 GET 请求参数中读取 stat_time、school 等固定条件，使用这些条件过滤数据库查询（例如：仅查询数据年份为 2023 的记录）。
   - **advanced_conditions 解析**：
      后端解析 advanced_conditions 参数，将 JSON 字符串转换为数组。
     - 遍历每个条件对象，根据 role 区分处理：
       - role 为 "filter"：直接根据字段、运算符和值构造过滤条件；
       - role 为 "metric"：如果对应的字段在 METRIC_CONFIG 中定义了可选项，则要求 value 必须为非空数组（否则返回错误）；
       - role 为 "group"：提取第一个出现的分组条件，构造分组表达式，忽略后续分组条件。
     - 所有过滤条件合并后用于构造 SQLAlchemy 查询。

2. **构造分组表达式与统计指标聚合**

   - **固定模板模式**：
     - template1：使用 SQLAlchemy case() 表达式，将年龄字段按照范围分为 “6-9岁”、“10-12岁” 和 “其他”；
     - template2：直接使用 Student.gender 作为分组字段。
   - **自定义查询模式**：
     - 分组表达式取 advanced_conditions 中第一条 role 为 "group" 的条件对应字段；
     - 此字段不依赖于 value，仅作为分组依据。
   - **统计指标聚合**：
     - 对于每个 role 为 "metric" 的条件，后端根据用户选择的子选项（value 数组）构造动态统计指标配置。
     - 对于每个选项，通过 SQLAlchemy 的 func.sum() 和 case() 函数构造聚合表达式，统计符合该选项的记录数。
     - 同时再加上统计总数的 count() 表达式。
     - 注意：最新 SQLAlchemy 要求 case() 的 when 条件作为位置参数而不是列表。

3. **生成表头和数据行**

   - 调用 build_multi_level_header() 函数生成三层表头。
     - 第一行：第一列为分组字段名称（跨 3 行），中间为统计指标名称（跨用户选择的所有子选项列数），最后一列为“统计总数”（跨 3 行）。
     - 第二行：第一列为空，中间部分显示每个统计指标下的具体子选项（或直接“数量”、“占比”），最后一列为空。
     - 第三行：第一列为空，中间部分对每个子选项固定生成“数量”与“占比”两个单元格，最后一列为空。
   - 对于数据行，后端从数据库查询结果中，构造二维数组：
     - 第一列为分组值（例如“男”、“女”、“6-9岁”、“10-12岁”等）；
     - 中间部分按顺序交替填入各子选项的统计数据和计算出的占比；
     - 最后一列为该分组的统计总数。
   - 合计行将所有数据行汇总。

4. **报表名称与附注信息构造**

   - 报表名称

     ：

     - 固定模板模式下，名称固定为 “{stat_time}-学生视力统计表”。
     - 自定义查询模式下，优先使用用户输入的报表名称，若为空则默认使用 “统计报表”。

   - 附注信息

     ：

     - 收集所有固定筛选条件和 role 为 "filter" 的条件，按格式拼接成附注字符串，例如 “统计时间：2023 学校：兴华小学 性别：男”。

5. **返回数据格式**

   - 后端将生成的报表名称、附注、表头（二维数组）、数据行（二维数组）和总记录数作为 JSON 格式返回给前端。

------

### 三、技术环境与框架

1. **后端环境**
   - Flask 框架，使用 Flask-SQLAlchemy 进行 ORM 操作
   - 数据库使用 SQLite
   - 使用最新 SQLAlchemy 语法要求，确保 case() 调用、分页等均符合新版本要求
2. **前端环境**
   - HTML5、CSS3、原生 JavaScript
   - 使用 Bootstrap 5 进行页面布局和组件样式设计
   - 使用 Chart.js 作为图表展示库（报表与图表页面可复用部分组件）
   - 组合查询模块由 comboQuery_report.js 实现，确保自定义查询条件准确收集并传递
3. **代码规范**
   - 所有代码必须严格遵守 PEP8 和 Pylint 规范，代码格式、注释和命名须统一清晰
   - 修改代码时，必须保证现有功能不受影响，所有新增和修改必须经过充分测试

------

### 总结

系统整体流程从前端用户通过固定筛选和自定义组合查询选择条件、统计指标和分组条件开始，通过前端收集参数后构造 GET 请求；后端解析所有参数后构造数据库查询，并利用最新 SQLAlchemy 语法构造分组与聚合表达式；再通过生成三层表头和数据行，构造报表的最终输出，同时报表名称和附注信息基于筛选条件生成；最终返回 JSON 数据供前端展示。

请确认以上技术方案描述是否清楚、完整，如有需要进一步补充和调整的部分，请指出。

以下是我检查现有代码后发现的问题以及下一步的工作计划：

------

### 检查结果

1. **高级查询条件解析问题**
   - 在 advanced_conditions 中，虽然用户在自定义查询时已经选择了“视力等级”为统计指标和“性别”为分组，但在后端解析时，分组条件（role 为 "group" 的条件）没有正确提取，导致 grouping_cols 为空，最终触发错误“必须指定分组条件”。
   - 分析发现：
     - 高级查询条件中，“性别”字段作为分组条件被传递，但后端代码只取了第一条分组条件；可能存在映射问题（例如前端使用中文而后端内部使用英文字段名）；
     - 此外，组合查询模块中多选条件的处理需要确保顺序和完整性，这也可能影响统计指标的排序和结果构造。
2. **动态统计指标聚合和表头构造问题**
   - 当前聚合计算部分使用 SQLAlchemy 的 case() 函数时，出现 “The 'whens' argument to case() …” 错误，说明代码未按照最新 SQLAlchemy 版本的要求传递参数（位置参数而非列表）。
   - 同时，动态生成表头部分存在顺序问题：统计指标子选项顺序不符合用户选择顺序（例如用户全选的复选框顺序与生成结果不一致），并且出现了不应该存在的“正常”指标，这表明在聚合计算时可能存在默认值或硬编码问题。
3. **报表名称与附注信息**
   - 固定模板模式下报表名称应固定为“{stat_time}-学生视力统计表”，而自定义模式下报表名称为用户输入或默认为“统计报表”。目前代码中报表名称生成和附注信息构造不完全符合需求，附注中应显示所有筛选条件（不仅仅是统计时间）。
4. **前端参数收集和传递**
   - 前端 report.js 在收集自定义查询条件时，调用 getComboConditions() 的部分需要确保多选复选框中的值按用户选择的顺序保留，且不会默认采用空值。
   - 此外，部分 DOM 元素（例如报表名称输入框、附注信息元素）在清除时和查询时可能没有正确重置或更新。

------

### 下一步工作计划

1. **调整高级查询条件解析逻辑（后端 analysis_api.py）**
   - 检查并修正解析 advanced_conditions 的逻辑，确保从传递过来的 JSON 数组中正确提取 role 为 "group" 的条件。
   - 解决前端传递中文字段名称的问题，确保后端有正确的字段映射（例如“性别”映射到 Student.gender）。
2. **修正 SQLAlchemy case() 调用**
   - 按照最新版本要求，调整 case() 函数中 when 条件的传递方式，将条件作为位置参数传递，而不是传递列表。
3. **完善统计指标和表头构造逻辑**
   - 确保动态统计指标部分根据用户选择的子选项生成聚合表达式时，保留用户选择的顺序。
   - 修正表头生成函数 build_multi_level_header()，使其生成的三层表头满足如下要求：
     - 第一行：第一列显示分组字段名称（跨三行），中间单元格为统计指标名称（横跨用户选择的子选项列数），最后一列为“统计总数”（跨三行）。
     - 第二行：第一列为空，中间部分显示各个子选项名称（只显示用户勾选的子选项），最后一列为空。
     - 第三行：第一列为空，中间部分固定生成“数量”和“占比”两个单元格（每个子选项两列），最后一列为空。
4. **完善报表名称和附注信息构造**
   - 在后端生成报表数据时，根据查询模式区分固定模板和自定义模板：
     - 固定模板下，文件名称固定为“{stat_time}-学生视力统计表”；
     - 自定义模式下，若用户输入报表名称则采用，否则默认为“统计报表”。
   - 附注信息要将所有筛选条件（固定查询条件和 advanced_conditions 中 role 为 "filter" 的条件）拼接成字符串返回。
5. **前端调整**
   - 检查 report.js 中 getReportQueryParams() 和调用 getComboConditions() 的部分，确保传递的 advanced_conditions 参数结构正确且顺序正确。
   - 确保前端 DOM 中显示报表名称和附注信息的元素在收到后端数据时能够正确更新。
6. **整体联调与测试**
   - 修改完后，通过固定模板和自定义查询两种模式分别进行测试。
   - 在自定义查询中，确保当用户未选择统计指标子选项或分组条件时，系统能够给出明确提示（返回错误信息）；
   - 同时验证最终生成的报表表头、数据行、合计行、报表名称和附注信息是否符合需求。

------

以上是我检查问题的详细结果和下一步代码修改及测试工作的计划。请确认是否符合您的要求或是否有其他补充要求。